package main

import (
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/btcsuite/btcd/btcjson"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/rpcclient"
	"github.com/linkpoolio/bridges/bridge"
)

// Bitcoin is the main object
type Bitcoin struct{}

///////////////////////////////
// getblockcount
///////////////////////////////
// Parameters
// None
///////////////////////////////
// Description
// Returns the number of blocks in the longest block chain.
///////////////////////////////
func getBlockCount(client *rpcclient.Client) (int64, error) {
	return client.GetBlockCount()
}

///////////////////////////////
// getdifficulty
///////////////////////////////
// Parameters
// None
///////////////////////////////
// Description
// Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
///////////////////////////////
// getDifficulty returns the proof-of-work difficulty as a multiple of the minimum difficulty
func getDifficulty(client *rpcclient.Client) (float64, error) {
	return client.GetDifficulty()
}

///////////////////////////////
// getrawtransaction
///////////////////////////////
// Parameters
// 1. transaction hash (string, required) - the hash of the transaction
///////////////////////////////
// Description
// Returns information about a transaction given its hash.
///////////////////////////////
func getRawTransaction(client *rpcclient.Client, txID *chainhash.Hash, verbose bool) (*btcjson.TxRawResult, error) {
	result, err := client.GetRawTransactionVerbose(txID)
	if err != nil {
		return &btcjson.TxRawResult{}, err
	}

	return result, nil
}

///////////////////////////////
// getblock
///////////////////////////////
// Parameters
// 1. block_num (string, required) - the number of the block
///////////////////////////////
// Description
// Returns information about a transaction given its hash.
///////////////////////////////
func getBlock(client *rpcclient.Client, blockNum int64, verbose bool, verboseTx bool) (*btcjson.GetBlockVerboseResult, error) {
	// First get block hash of the given block num
	blockHash, err := client.GetBlockHash(blockNum)
	if err != nil {
		return &btcjson.GetBlockVerboseResult{}, err
	}

	// Get the block result JSON object
	result, err := client.GetBlockVerboseTx(blockHash)
	if err != nil {
		return &btcjson.GetBlockVerboseResult{}, err
	}

	return result, nil
}

// Run is called on each HTTP request
func (btc *Bitcoin) Run(h *bridge.Helper) (interface{}, error) {
	//Return object
	obj := make(map[string]interface{})

	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	certs, err := ioutil.ReadFile(os.Getenv("BTCD_RPC_CERT"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         os.Getenv("BTCD_RPC_HOST"),
		Endpoint:     "ws",
		User:         os.Getenv("BTCD_RPC_USER"),
		Pass:         os.Getenv("BTCD_RPC_PASS"),
		Certificates: certs,
	}

	// Create a btcd client object
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Println(err)
		return nil, errors.New("Unable to connect to btcd instance")
	}
	defer client.Shutdown()

	// Check rpc_command converting it to lowercase to make it case-insensitive
	switch command := strings.ToLower(h.GetParam("rpc_command")); command {
	case "getblockcount":
		{
			blockCount, err := getBlockCount(client)
			if err != nil {
				return nil, err
			}

			obj["block_count"] = blockCount
		}

	case "getdifficulty":
		{
			difficulty, err := getDifficulty(client)
			if err != nil {
				return nil, err
			}

			obj["difficulty"] = difficulty
		}

	case "getrawtransaction":
		{
			txHash, err := chainhash.NewHashFromStr(h.GetParam("tx_id"))
			if err != nil {
				return nil, errors.New("Invalid tx_id specified")
			}

			// Hard-coded verbose result
			txResult, err := getRawTransaction(client, txHash, true)
			if err != nil {
				return nil, err
			}

			obj["tx"] = txResult
		}

	case "getblock":
		{
			// Hard-coded verbose result
			blockResult, err := getBlock(client, h.GetIntParam("block_num"), true, true)
			if err != nil {
				return nil, err
			}

			obj["block"] = blockResult
		}

	default:
		return nil, errors.New("Invalid or unsupported rpc_command specified")
	}

	return obj, nil
}

// Opts is called on startup
func (btc *Bitcoin) Opts() *bridge.Opts {
	return &bridge.Opts{
		Name:   "Bitcoin",
		Lambda: true,
	}
}

// Handler is used for GCP compatibility
func Handler(w http.ResponseWriter, r *http.Request) {
	bridge.NewServer(&Bitcoin{}).Handler(w, r)
}

func main() {
	// Start the HTTP server
	port, err := strconv.Atoi(os.Getenv("LISTEN_PORT"))
	if err != nil {
		port = 8080
	}

	bridge.NewServer(&Bitcoin{}).Start(port)
}
