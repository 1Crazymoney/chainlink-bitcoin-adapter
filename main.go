package main

import (
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/btcsuite/btcd/rpcclient"
	"github.com/linkpoolio/bridges/bridge"
)

// Bitcoin is the main object
type Bitcoin struct{}

// getBlockCount returns the current block count
func getBlockCount(client *rpcclient.Client) (int64, error) {
	return client.GetBlockCount()
}

// Run is called on each HTTP request
func (btc *Bitcoin) Run(h *bridge.Helper) (interface{}, error) {
	//Return object
	obj := make(map[string]interface{})

	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	certs, err := ioutil.ReadFile(os.Getenv("BTCD_RPC_CERT"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         os.Getenv("BTCD_RPC_HOST"),
		Endpoint:     "ws",
		User:         os.Getenv("BTCD_RPC_USER"),
		Pass:         os.Getenv("BTCD_RPC_PASS"),
		Certificates: certs,
	}

	// Create a btcd client object
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Println(err)
		return nil, errors.New("Unable to connect to btcd instance")
	}
	defer client.Shutdown()

	// Check rpc_command converting it to lowercase to make it case-insensitive
	switch command := strings.ToLower(h.GetParam("rpc_command")); command {
	case "getblockcount":
		blockCount, err := getBlockCount(client)
		if err != nil {
			return nil, err
		}

		obj["block_count"] = blockCount

	default:
		return nil, errors.New("Invalid or unsupported rpc_command specified")
	}

	return obj, nil
}

// Opts is called on startup
func (btc *Bitcoin) Opts() *bridge.Opts {
	return &bridge.Opts{
		Name:   "Bitcoin",
		Lambda: true,
	}
}

// Handler is used for GCP compatibility
func Handler(w http.ResponseWriter, r *http.Request) {
	bridge.NewServer(&Bitcoin{}).Handler(w, r)
}

func main() {
	// Start the HTTP server
	bridge.NewServer(&Bitcoin{}).Start(8080)
}
