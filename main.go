package main

import (
	"errors"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/btcsuite/btcd/btcjson"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/rpcclient"
	"github.com/linkpoolio/bridges/bridge"
)

// Bitcoin is the main object
type Bitcoin struct{}

///////////////////////////////
// getblockcount
///////////////////////////////
// Parameters
// None
///////////////////////////////
// Description
// Returns the number of blocks in the longest block chain.
///////////////////////////////
func getBlockCount(client *rpcclient.Client) (int64, error) {
	return client.GetBlockCount()
}

///////////////////////////////
// getdifficulty
///////////////////////////////
// Parameters
// None
///////////////////////////////
// Description
// Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
///////////////////////////////
// getDifficulty returns the proof-of-work difficulty as a multiple of the minimum difficulty
func getDifficulty(client *rpcclient.Client) (float64, error) {
	return client.GetDifficulty()
}

///////////////////////////////
// getrawtransaction
///////////////////////////////
// Parameters
// 1. transaction hash (string, required) - the hash of the transaction
// 2. verbose (int, optional, default=0) - specifies the transaction is returned as a JSON object instead of hex-encoded string
///////////////////////////////
// Description
// Returns information about a transaction given its hash.
///////////////////////////////
type txResult struct {
	rawTx *btcjson.TxRawResult
	txHex string
}

func getRawTransaction(client *rpcclient.Client, txID *chainhash.Hash, verbose bool) (*txResult, error) {
	var returnResult txResult

	result, err := client.GetRawTransactionVerbose(txID)
	if err != nil {
		return &txResult{}, err
	}

	returnResult.txHex = result.Hex

	if verbose {
		// Put result into return object
		returnResult.rawTx = result
	}

	return &returnResult, nil
}

// Run is called on each HTTP request
func (btc *Bitcoin) Run(h *bridge.Helper) (interface{}, error) {
	//Return object
	obj := make(map[string]interface{})

	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	certs, err := ioutil.ReadFile(os.Getenv("BTCD_RPC_CERT"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         os.Getenv("BTCD_RPC_HOST"),
		Endpoint:     "ws",
		User:         os.Getenv("BTCD_RPC_USER"),
		Pass:         os.Getenv("BTCD_RPC_PASS"),
		Certificates: certs,
	}

	// Create a btcd client object
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Println(err)
		return nil, errors.New("Unable to connect to btcd instance")
	}
	defer client.Shutdown()

	// Check rpc_command converting it to lowercase to make it case-insensitive
	switch command := strings.ToLower(h.GetParam("rpc_command")); command {
	case "getblockcount":
		{
			blockCount, err := getBlockCount(client)
			if err != nil {
				return nil, err
			}

			obj["block_count"] = blockCount
		}

	case "getdifficulty":
		{
			difficulty, err := getDifficulty(client)
			if err != nil {
				return nil, err
			}

			obj["difficulty"] = difficulty
		}

	case "getrawtransaction":
		{
			txHash, err := chainhash.NewHashFromStr(h.GetParam("tx_id"))
			if err != nil {
				return nil, errors.New("Invalid tx_id specified")
			}

			verbose := h.GetParam("verbose") == "true"

			txResult, err := getRawTransaction(client, txHash, verbose)
			if err != nil {
				return nil, err
			}

			if txResult.rawTx != nil {
				obj["tx_raw"] = txResult.rawTx
			}
			obj["tx_hex"] = txResult.txHex
		}

	default:
		return nil, errors.New("Invalid or unsupported rpc_command specified")
	}

	return obj, nil
}

// Opts is called on startup
func (btc *Bitcoin) Opts() *bridge.Opts {
	return &bridge.Opts{
		Name:   "Bitcoin",
		Lambda: true,
	}
}

// Handler is used for GCP compatibility
func Handler(w http.ResponseWriter, r *http.Request) {
	bridge.NewServer(&Bitcoin{}).Handler(w, r)
}

func main() {
	// Start the HTTP server
	port, err := strconv.Atoi(os.Getenv("LISTEN_PORT"))
	if err != nil {
		port = 8080
	}

	bridge.NewServer(&Bitcoin{}).Start(port)
}
