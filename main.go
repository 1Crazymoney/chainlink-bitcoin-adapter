package main

import (
	"github.com/btcsuite/btcd/rpcclient"
	"io/ioutil"
	"log"
	//"github.com/linkpoolio/bridges/bridge"
	//"net/http"
	//"os"
	"os"
)


// type AlphaVantage struct {}

// func (av *AlphaVantage) Run(h *bridge.Helper) (interface{}, error) {
// 	r := make(map[string]interface{})
// 	return r, h.HTTPCallWithOpts(
// 		http.MethodGet,
// 		"https://www.alphavantage.co/query",
// 		&r,
// 		bridge.CallOpts{
// 			Auth: bridge.NewAuth(bridge.AuthParam, "apikey", os.Getenv("API_KEY")),
// 			QueryPassthrough: true,
// 		},
// 	)
// }

// func (av *AlphaVantage) Opts() *bridge.Opts {
// 	return &bridge.Opts{
// 		Name:   "AlphaVantage",
// 		Lambda: true,
// 	}
// }

func main() {
	// bridge.NewServer(&AlphaVantage{}).Start(8080)

	// Load the certificate for the TLS connection which is automatically
	// generated by btcd when it starts the RPC server and doesn't already
	// have one.
	certs, err := ioutil.ReadFile(os.Getenv("BTCD_RPC_CERT"))
	if err != nil {
		log.Fatal(err)
	}

	// Create a new RPC client using websockets.  Since this example is
	// not long-lived, the connection will be closed as soon as the program
	// exits.
	connCfg := &rpcclient.ConnConfig{
		Host:         os.Getenv("BTCD_RPC_HOST"),
		Endpoint:     "ws",
		User:         os.Getenv("BTCD_RPC_USER"),
		Pass:         os.Getenv("BTCD_RPC_PASS"),
		Certificates: certs,
	}
	client, err := rpcclient.New(connCfg, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer client.Shutdown()

	// Query the RPC server for the current block count and display it.
	blockCount, err := client.GetBlockCount()
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Block count: %d", blockCount)
}
